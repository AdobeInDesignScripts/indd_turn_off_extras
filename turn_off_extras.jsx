if ( app.documents.length ) main();function main() {	var _l = {};	// set in init()	init();	var doc = app.activeDocument;	var aux = localize( _l.textPreferences );	var prefs = {		textPreferences: {			name: localize( _l.textPreferences ),			enableStylePreviewMode: localize( _l.enableStylePreviewMode ),			highlightCustomSpacing: localize( _l.highlightCustomSpacing ),			highlightHjViolations: localize( _l.highlightHjViolations ),			highlightKeeps: localize( _l.highlightKeeps ),			highlightKinsoku: localize( _l.highlightKinsoku ),			highlightSubstitutedFonts: localize( _l.highlightSubstitutedFonts ),			highlightSubstitutedGlyphs: localize( _l.highlightSubstitutedGlyphs ),			showInvisibles: localize( _l.showInvisibles ),		},		gridPreferences: {			name: localize( _l.gridPreferences ),			baselineGridShown: localize( _l.baselineGridShown ),			documentGridShown: localize( _l.documentGridShown ),		},		guidePreferences: {			name: localize( _l.guidePreferences ),			guidesShown: localize( _l.guidesShown ),		},		viewPreferences: {			name: localize( _l.viewPreferences ),			showFrameEdges: localize( _l.showFrameEdges ),			showNotes: localize( _l.showNotes ),		},		xmlViewPreferences: {			name: localize( _l.xmlViewPreferences ),			showTaggedFrames: localize( _l.showTaggedFrames ),			showTagMarkers: localize( _l.showTagMarkers )		}	}		for ( var p1 in prefs ) {		for ( var p2 in prefs[p1] ) {			if ( doc.hasOwnProperty( p1 ) ) {				if ( doc[p1].hasOwnProperty( p2 ) ) {					prefs[p1][p2 + "_value"] = doc[p1][p2];				} else {				}			} else {			} 		}	}	if ( doc.extractLabel("gs_prefs_resetter") == "" ) {		doc.insertLabel( "gs_prefs_resetter", JSON.stringify( prefs ) );	}		var w = new Window("dialog");	w.orientation ="row";	w.alignChildren = "top";	w.main = w.add("group");	w.main.orientation = "column";	w.main.alignChildren = "fill";	for ( var p in prefs ) {		w.main[p] = w.main.add( "panel" );		w.main[p].text = prefs[p].name;		w.main[p].alignChildren = "fill";		for ( var o in prefs[p] ) {			if ( o.search(/_value/) == -1 && o != "name") {				var aux = w.main[p].add("group");				aux.alignChildren = "bottom"				w.main[p][o] = aux.add('checkbox');				w.main[p][o].value = prefs[p][o+"_value"];				aux.add("statictext", undefined, prefs[p][o] );			}		}	}	w.btns = w.add("group");	w.btns.orientation = "column";	w.btns.alignChildren = "fill";	w.defaultElement = w.btns.add("button", undefined, localize( _l.defaultElement ));	w.btns.cancel = w.btns.add("button", undefined, localize( _l.cancel ));	w.btns.ok = w.btns.add("button", undefined, localize( _l.ok ) );	w.btns.restore = w.btns.add("button", undefined, localize( _l.restore ), {enabled: doc.extractLabel("gs_prefs_resetter") != ""} );	w.btns.last_combo = w.btns.add("button", undefined, localize( _l.last_combo ), {enabled: app.extractLabel("gs_extras_off_last_settings") != ""} );		w.btns.ok.onClick = function() {		for ( var p in prefs ) {			for ( var o in prefs[p] ) {				if ( o != "name" && o.search("_value") == -1 ) {					prefs[p][o] = this.window.main[p][o].value;					prefs[p][o + '_value'] = prefs[p][o];				}			}		}		w.close(1);	}	w.btns.cancel.onClick = function() {		w.close(2);	}	w.defaultElement.onClick = function() {		w.close(3);	}	w.defaultElement.notify = function() {		w.close(3);	}	w.btns.restore.onClick = function() {		w.close(4);			}	w.btns.last_combo.onClick = function() {		w.close(5);	}			var todo = w.show();	if ( todo == 1 ) {		app.insertLabel( "gs_extras_off_last_settings",  prefs.toSource() );		// $.writeln( "//from dialog:\r" + prefs.toSource() );		for ( var p in prefs ) {			// $.writeln( "// " + p );			for ( var o in prefs[p] ) {				// $.writeln( "// .. " + o );				if ( o != "name" && o.search(/_value/) == -1 ) {					doc[p][o] = prefs[p][o];					// $.writeln( "// " + p + "." + o + " = " + prefs[p][o] );				}			}		}			} else if ( todo == 3 ) {		for ( var p in prefs ) {			for ( var o in prefs[p] ) {				if ( o.search(/_value/) == -1 && o != "name") {					doc[p][o] = false;				}			}		}			} else if ( todo == 4 ) {		var saved = doc.extractLabel( "gs_prefs_resetter" );		if ( saved != "" ) {			saved = JSON.parse( saved );			for ( var p in saved ) {				// $.writeln( p );				for ( var o in saved[p] ) {					if ( o.search(/_value/) == -1 && o != "name") {						// $.writeln( o );						if ( saved[p].hasOwnProperty(o + "_value") ) {							doc[p][o] = saved[p][o + "_value"];							// $.writeln( " -> " + saved[p][o + "_value"] );						}	// has _value					}		// value in o				}			// for o in p			}				// for p in saved		}					// if saved	} else if ( todo == 5 ) {		var saved = app.extractLabel( "gs_extras_off_last_settings" );		// $.writeln("// extracted");		// $.writeln( saved );		if ( saved != "" ) {//			saved = JSON.parse( saved );			saved = eval( saved );			for ( var p in saved ) {				// $.writeln( p );				for ( var o in saved[p] ) {					if ( o.search(/_value/) == -1 && o != "name") {						// $.writeln( o );						if ( saved[p].hasOwnProperty(o + "_value") ) {							doc[p][o] = saved[p][o + "_value"];							// $.writeln( " -> " + saved[p][o + "_value"] );						}	// has _value					}		// value in o				}			// for o in p			}				// for p in saved		}					// if saved	}						// if todo == x	function init() {				_l = {				textPreferences: { 						de: 'Text Einstellungen',						en: 'Text Preferences',						fr: 'Paramètres de texte'				},				enableStylePreviewMode: { 						de: 'Formatabweichungen anzeigen',						en: 'Style Preview Mode',						fr: 'Surligneur de remplacement de style'				},				highlightCustomSpacing: { 						de: 'Spationierung anzeigen',						en: 'Custom Spacing',						fr: 'Approche/Crénage personalisés'				},				highlightHjViolations: { 						de: 'Silbentrennung anzeigen',						en: 'HJ Violations',						fr: 'Infraction de césures et de justification'				},				highlightKeeps: { 						de: 'Umbruchverletzung anzeigen',						en: 'Keeps Violations',						fr: 'Infraction d’enchainement'				},				highlightKinsoku: { 						de: 'Kinsoku anzeigen',						en: 'Kinsoku',						fr: 'Composition Kinsoku'				},				highlightSubstitutedFonts: { 						de: 'Ersetzte Schriften anzeigen',						en: 'Substituted Fonts',						fr: 'Polices substituées' 				},				highlightSubstitutedGlyphs: { 						de: 'Ersetzte Glyphen anzeigen',						en: 'Substituted Glyphs',						fr: 'Glyphes remplacés'				},				showInvisibles: { 						de: 'Verborgene Zeichen anzeigen',						en: 'Show Invisibles',						fr: 'Afficher les caractères masqués'				},				 				 				gridPreferences: { 						de: 'Raster Einstellungen',						en: 'Grid Preferences',						fr: 'Paramètres de la grille'				},				baselineGridShown: { 						de: 'Grundlinienraster anzeigen',						en: 'Baseline Grid',						fr: 'Afficher la grille de ligne de base'				},				documentGridShown: { 						de: 'Dokumentraster azeigen',						en: 'Document Grid',						fr: 'Afficher la grille de document'				},				 				 				guidePreferences: { 						de: 'Hilfslinien Einstellungen',						en: 'Guides',						fr: 'Paramètres des guides'				},				guidesShown: { 						de: 'Hilfslinien anzeigen',						en: 'Show Guides',						fr: 'Afficher les guides'				},				 				 				viewPreferences: { 						de: 'Fenster Einstellungen',						en: 'View Preferences',						fr: 'Paramètres d’affichage'				},				showFrameEdges: { 						de: 'Rahmenkanten anzeigen',						en: 'Show Frame Edges',						fr: 'Afficher le contour des blocs'				},				showNotes: { 						de: 'Notizen anzeigen',						en: 'Show Notes',						fr: 'Afficher les notes'				},				 				 				xmlViewPreferences: { 						de: 'XML Einstellungen',						en: 'XML Preferences',						fr: 'Paramètres XML'				},				showTaggedFrames: { 						de: 'Getaggte Rahmen anzeigen',						en: 'Show Tagged Frames',						fr: 'Afficher les blocs balisés'				},				showTagMarkers: { 						de: 'Tagmarken anzeigen',						en: 'Show Tag Markers',						fr: 'Afficher les marques des balises'				},				 				 				defaultElement: { 						de: 'Alle aus',						en: 'Everything off',						fr: 'Désactiver tout'				},				cancel: { 						de: 'Abbrechen',						en: 'Cancel',						fr: 'Annuler'				},				ok: { 						de: 'Anwenden',						en: 'Apply',						fr: 'Appliquer'				},				restore: { 						de: 'org. Zustand',						en: 'Initial Settings',						fr: 'Restaurer les paramêtres'				},				last_combo: { 						de: 'letzte Kombo',						en: 'Last Combo',						fr: 'Dernier Combo'				}		}   				// JSON2: https://www.npmjs.com/package/JSON2				if (typeof JSON !== "object") {			JSON = {};		}		(function () {			"use strict";			var rx_one = /^[\],:{}\s]*$/;			var rx_two = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g;			var rx_three = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;			var rx_four = /(?:^|:|,)(?:\s*\[)+/g;			var rx_escapable = /[\\"\u0000-\u001f\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;			var rx_dangerous = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;			function f(n) {				// Format integers to have at least two digits.				return (n < 10)					? "0" + n					: n;			}			function this_value() {				return this.valueOf();			}			if (typeof Date.prototype.toJSON !== "function") {				Date.prototype.toJSON = function () {					return isFinite(this.valueOf())						? (							this.getUTCFullYear()							+ "-"							+ f(this.getUTCMonth() + 1)							+ "-"							+ f(this.getUTCDate())							+ "T"							+ f(this.getUTCHours())							+ ":"							+ f(this.getUTCMinutes())							+ ":"							+ f(this.getUTCSeconds())							+ "Z"						)						: null;				};				Boolean.prototype.toJSON = this_value;				Number.prototype.toJSON = this_value;				String.prototype.toJSON = this_value;			}			var gap;			var indent;			var meta;			var rep;			function quote(string) {		// If the string contains no control characters, no quote characters, and no		// backslash characters, then we can safely slap some quotes around it.		// Otherwise we must also replace the offending characters with safe escape		// sequences.				rx_escapable.lastIndex = 0;				return rx_escapable.test(string)					? "\"" + string.replace(rx_escapable, function (a) {						var c = meta[a];						return typeof c === "string"							? c							: "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);					}) + "\""					: "\"" + string + "\"";			}			function str(key, holder) {		// Produce a string from holder[key].				var i;          // The loop counter.				var k;          // The member key.				var v;          // The member value.				var length;				var mind = gap;				var partial;				var value = holder[key];		// If the value has a toJSON method, call it to obtain a replacement value.				if (					value					&& typeof value === "object"					&& typeof value.toJSON === "function"				) {					value = value.toJSON(key);				}		// If we were called with a replacer function, then call the replacer to		// obtain a replacement value.				if (typeof rep === "function") {					value = rep.call(holder, key, value);				}		// What happens next depends on the value's type.				switch (typeof value) {				case "string":					return quote(value);				case "number":		// JSON numbers must be finite. Encode non-finite numbers as null.					return (isFinite(value))						? String(value)						: "null";				case "boolean":				case "null":		// If the value is a boolean or null, convert it to a string. Note:		// typeof null does not produce "null". The case is included here in		// the remote chance that this gets fixed someday.					return String(value);		// If the type is "object", we might be dealing with an object or an array or		// null.				case "object":		// Due to a specification blunder in ECMAScript, typeof null is "object",		// so watch out for that case.					if (!value) {						return "null";					}		// Make an array to hold the partial results of stringifying this object value.					gap += indent;					partial = [];		// Is the value an array?					if (Object.prototype.toString.apply(value) === "[object Array]") {		// The value is an array. Stringify every element. Use null as a placeholder		// for non-JSON values.						length = value.length;						for (i = 0; i < length; i += 1) {							partial[i] = str(i, value) || "null";						}		// Join all of the elements together, separated with commas, and wrap them in		// brackets.						v = partial.length === 0							? "[]"							: gap								? (									"[\n"									+ gap									+ partial.join(",\n" + gap)									+ "\n"									+ mind									+ "]"								)								: "[" + partial.join(",") + "]";						gap = mind;						return v;					}		// If the replacer is an array, use it to select the members to be stringified.					if (rep && typeof rep === "object") {						length = rep.length;						for (i = 0; i < length; i += 1) {							if (typeof rep[i] === "string") {								k = rep[i];								v = str(k, value);								if (v) {									partial.push(quote(k) + (										(gap)											? ": "											: ":"									) + v);								}							}						}					} else {		// Otherwise, iterate through all of the keys in the object.						for (k in value) {							if (Object.prototype.hasOwnProperty.call(value, k)) {								v = str(k, value);								if (v) {									partial.push(quote(k) + (										(gap)											? ": "											: ":"									) + v);								}							}						}					}		// Join all of the member texts together, separated with commas,		// and wrap them in braces.					v = partial.length === 0						? "{}"						: gap							? "{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}"							: "{" + partial.join(",") + "}";					gap = mind;					return v;				}			}		// If the JSON object does not yet have a stringify method, give it one.			if (typeof JSON.stringify !== "function") {				meta = {    // table of character substitutions					"\b": "\\b",					"\t": "\\t",					"\n": "\\n",					"\f": "\\f",					"\r": "\\r",					"\"": "\\\"",					"\\": "\\\\"				};				JSON.stringify = function (value, replacer, space) {		// The stringify method takes a value and an optional replacer, and an optional		// space parameter, and returns a JSON text. The replacer can be a function		// that can replace values, or an array of strings that will select the keys.		// A default replacer method can be provided. Use of the space parameter can		// produce text that is more easily readable.					var i;					gap = "";					indent = "";		// If the space parameter is a number, make an indent string containing that		// many spaces.					if (typeof space === "number") {						for (i = 0; i < space; i += 1) {							indent += " ";						}		// If the space parameter is a string, it will be used as the indent string.					} else if (typeof space === "string") {						indent = space;					}		// If there is a replacer, it must be a function or an array.		// Otherwise, throw an error.					rep = replacer;					if (replacer && typeof replacer !== "function" && (						typeof replacer !== "object"						|| typeof replacer.length !== "number"					)) {						throw new Error("JSON.stringify");					}		// Make a fake root object containing our value under the key of "".		// Return the result of stringifying the value.					return str("", {"": value});				};			}		// If the JSON object does not yet have a parse method, give it one.			if (typeof JSON.parse !== "function") {				JSON.parse = function (text, reviver) {		// The parse method takes a text and an optional reviver function, and returns		// a JavaScript value if the text is a valid JSON text.					var j;					function walk(holder, key) {		// The walk method is used to recursively walk the resulting structure so		// that modifications can be made.						var k;						var v;						var value = holder[key];						if (value && typeof value === "object") {							for (k in value) {								if (Object.prototype.hasOwnProperty.call(value, k)) {									v = walk(value, k);									if (v !== undefined) {										value[k] = v;									} else {										delete value[k];									}								}							}						}						return reviver.call(holder, key, value);					}		// Parsing happens in four stages. In the first stage, we replace certain		// Unicode characters with escape sequences. JavaScript handles many characters		// incorrectly, either silently deleting them, or treating them as line endings.					text = String(text);					rx_dangerous.lastIndex = 0;					if (rx_dangerous.test(text)) {						text = text.replace(rx_dangerous, function (a) {							return (								"\\u"								+ ("0000" + a.charCodeAt(0).toString(16)).slice(-4)							);						});					}		// In the second stage, we run the text against regular expressions that look		// for non-JSON patterns. We are especially concerned with "()" and "new"		// because they can cause invocation, and "=" because it can cause mutation.		// But just to be safe, we want to reject all unexpected forms.		// We split the second stage into 4 regexp operations in order to work around		// crippling inefficiencies in IE's and Safari's regexp engines. First we		// replace the JSON backslash pairs with "@" (a non-JSON character). Second, we		// replace all simple value tokens with "]" characters. Third, we delete all		// open brackets that follow a colon or comma or that begin the text. Finally,		// we look to see that the remaining characters are only whitespace or "]" or		// "," or ":" or "{" or "}". If that is so, then the text is safe for eval.					if (						rx_one.test(							text								.replace(rx_two, "@")								.replace(rx_three, "]")								.replace(rx_four, "")						)					) {		// In the third stage we use the eval function to compile the text into a		// JavaScript structure. The "{" operator is subject to a syntactic ambiguity		// in JavaScript: it can begin a block or an object literal. We wrap the text		// in parens to eliminate the ambiguity.						j = eval("(" + text + ")");		// In the optional fourth stage, we recursively walk the new structure, passing		// each name/value pair to a reviver function for possible transformation.						return (typeof reviver === "function")							? walk({"": j}, "")							: j;					}		// If the text is not JSON parseable, then a SyntaxError is thrown.					throw new SyntaxError("JSON.parse");				};			}		}());	}}